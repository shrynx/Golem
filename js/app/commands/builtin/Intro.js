define(function (require, exports, module) {
  var __filename = module.uri || "", __dirname = __filename.substring(0, __filename.lastIndexOf("/") + 1);
  var IntroCommand, text, _code, _div, _img, _p, _pre, _ref, _table, _td, _tr;

_ref = require('hyper'), _div = _ref._div, _p = _ref._p, _table = _ref._table, _tr = _ref._tr, _td = _ref._td, _code = _ref._code, _img = _ref._img, _pre = _ref._pre;

text = "<b>Shem</b> is a new statically typed functional language compiled to JavaScript.\n<b>Golem</b> is a browser-based IDE for Shem.\n\nWhat you are looking at is Golem. If you give Golem a Shem program, it will run it. Click inside the input box in the top left and type:\n\n  <span style=\"font-family: Monaco, monospace\">\"Hello Golem!\"</span>\n\nNow press Enter. Congratulations, you have\n1) Written your first Shem program.\n2) Ran your own Shem program.\n3) Got set up with everything you need to write Shem programs.\n\nNext steps:\n- Run the command :help\n- Run the command :examples\n- Start breathing again after you spotted all the parentheses\n- Bug us on <a href=\"http://github.com/xixixao/shem\">Github</a>, download the <a href=\"http://github.com/xixixao/shem/desktop\">desktop version</a> that let's you edit real files\n- Learn <a href=\"http://github.com/xixixao/shem\">more</a>";

text = "You will write the famous binary search algorithm. The objective of this exercise is not to test your abilities or knowledge of the algorithm but to test the environment you will be using.\n\n1. To start off, place cursor in the top left input field and type the following character by character:\n    <code>(search 3 {1 2 3 4})</code>\n  and press Enter.\n\n  <code>search</code> should be colored in deep red. Hover over it with the cursor to see the error message. Whenever you see a name or parentheses in deep red, you can hover over them to see the error message.\n\n2. Click on <code>search</code>. Simple clicking selects names. Try it on the numbers. If you click behind a closing bracket, brace or parentheses, you will select the whole expression. Same if you click before an opening one.\n\n3. With <code>search</code> selected, press Ctrl-D, to define the function.\n\n4. You should see <code>search</code> turn blue. This is the color for functions being called.\n\n5. Now with the cursor still blinking on <code>search</code> (if it isn't, click on it again), press Ctrl-T, to insert its type.\n\n6. You should now have\n    <code>search (fn [x y]\n      (: (Fn Num (Array Num) f)))</code>\n  In the main editing area on the left. This is a function definition. Here <code>search</code> is in green, because it is a new name you are defining. After an empty space is the value of the definition, in this case a function. This will be the only function defintion we will need. <code>x</code> and <code>y</code> are parameters to the function. The expression starting with <code>:</code> is the type of the function.\n\n7. Click on <code>f</code> at the end of the type and press Backspace (delete on a Mac). You should see a list of suggestions. Type:\n    <code>N</code>\n  Now <code>Num</code> should be the first suggestion.\n\n8. Press Tab. The <code>Num</code> got inserted. Remember that you cannot use Enter to insert completions because it is reserved for making new lines.\n\n9. Now we have the complete type of our search function. You should still have cursor at Num, so press <code>)</code> twice. Now the whole type should be selected.\n\n10. Press Enter. You will no doubt get a list of suggestions again. Press Tab to insert <code>x</code>. Now look to the right, you see <code>3</code> below the call to search. That's right, because we just made it return the first argument. The completions are based on types, so <code>y</code> was not suggested, because we declared the return type of our function to be <code>Num</code>.\n\n11. Now, we are going to use the indexing method for implementing the binary search. Lets first rename the parameters. Click on the green <code>x</code> in the parameter list and type:\n    <code>what</code>\n  Now click on the <code>y</code> and type:\n    <code>in</code>\n  Great, now click back on the <code>x</code>. Type first:\n    <code>(</code>\n  The <code>x</code> should now be wrapped in parentheses and selected. We don't want to call x, so just type over it:\n    <code>search-in what 0 (size in) in</code>\n\n12. We have not defined <code>search-in</code>, so let's define it the same way we defined <code>search</code>. If the cursor is still at the <code>list</code> you can use the left arrow to get to <code>search-in</code>. Try moving around the current source with different arrows. Now select <code>search-in</code>, either using a click or the arrows, and press Ctrl-D.\n\n13. You should now have\n    <code>search-in (fn [n x y list]\n      )</code>\n  directly below the line we just edited. If you remember Haskell, this is like a definition inside the where clause.\n\n14. Now press Ctrl-U. The definition moves to the top scope. Because we passed in both the <code>what</code> and the <code>in</code> we do not have to have <code>search-in</code> inside of <code>search</code>.\n\n15. Rename <code>x</code> and <code>y</code> to <code>min</code> and <code>max</code>. Now if you get the cursor back to the empty space inside <code>search-in</code> the autocompletion will suggest all the parameters. They are all numbers. Select max, by typing <code>ma</code> or using the Down arrow key and hit Tab. You should now see that the result of calling <code>search</code> on the right is the length of passed-in the list. Try adding more numbers to the list and see how the changes are reflected immediately.\n\n16. Binary search looks at the middle number in the list each time. We therefore need to calculate the middle index. Instead of <code>max</code>, Type:\n    <code>(+ min (div 2 (- min max)))</code>\n  If the list has 5 elements, you should get the number 2. If it has 3, you should get 1. Try again to change the list and see what result you get.\n\n17. Let's give this number a name. If you click on any expression inside <code>(+ min (div 2 (- min max)))</code> you can select the whole parent expression by using toghether Command + Up arrow couple times. If you went to far, you can use Command + Down to select a child expression. Command + arrows work on the expression tree, so Command + Right/Left will select the sibling expression, not the next name or number.\n\n18. With the whole <code>(+ min (div 2 (- min max)))</code> expression selected, pres Ctrl-D and type:\n    <code>half</code>\n  The results should stay the same. Hit Escape to select only the top <code>half</code> reference.\n\n19. Now with cursor at <code>half</code> pres Command-(, which is Command-Shift-9. This wraps the <code>half</code> in a new call and lets you put in the function name. Type:\n    <code>at</code>\n  Press Right, Space, and type:\n    <code>in</code>\n  You should now have the call <code>(at half in)</code> as the body of the <code>search-in</code> function. If you look at the result, you should see something like:\n    <code>(Some value: 3)</code>\n  This is because <code>at</code> returns a the maybe type <code>?</code>. Hover over at to see its documentation.\n\n20. To get the value out of the maybe value, wrap it inside of a call to <code>!!</code>. You already know the Command-( shortcut. You should have:\n    <code>(!! (at half in))</code>\n  And the result shoud be the number in the middle of the list. Try to change the list to see this works.\n\n21. Let's call this value <code>middle</code>. Use Ctrl-D as we did when we defined <code>half</code> and hit Escape to cancel the multiple selection.\n\n22. We need to test the base condition, that <code>max</code> is strictly bigger than <code>min</code>. Wrap <code>middle</code> inside of a call and type:\n    <code>(if (>= max min)</code>\n  And press enter. Now press Shift-Enter and type:\n    <code>None</code>\n  Now press the Down arraow and wrap middle in the call to <code>Some</code>. You should have:\n    <code>(if (>= max min)\n      None\n      (Some middle))</code>\n\n23. You should see an error message, the result type, which is the last argument in the call to <code>Fn</code>, of <code>search</code> does not match what <code>search-in</code> returns. Wrap the <code>Num</code> in a call to <code>?</code>.\n\n24. Now we are ready to finish the algorithm. This is a mouth-ful, but imagine how much code it would be in Java! Select the following code, all of it, copy it (Command-C) and then select the <code>(Some middle)</code> expression and press Command-V to paste over it:\n\n<code>(match (compare n middle)\n  LT (search-in n min half list)\n  GT (search-in n (+ 1 half) max list)\n  EQ (Some half))</code>\n\n25. Can you read the code? Could you tell what it does? Try chaning the values on the right and see that the result is correct.\n\n26. Last step, replace <code>(compare n middle)</code> with <code>(log min max half n (compare n middle))</code>. You should see a logging output on the right. Again, play around with the inputs to <code>search</code>. Can you tell now what is happening?";

IntroCommand = (function() {
  function IntroCommand() {}

  IntroCommand.defaultSymbols = ['intro'];

  IntroCommand.description = 'Show introduction';

  IntroCommand.symbols = IntroCommand.defaultSymbols;

  IntroCommand.execute = function(args, state, editor) {
    var intro;
    intro = _div({
      style: {
        padding: '25px'
      }
    }, _div({
      style: {
        'font-size': '13px',
        'line-height': '16px',
        'white-space': 'pre-wrap',
        'max-height': '600px',
        'overflow': 'scroll'
      },
      className: 'messageDisplay intro',
      dangerouslySetInnerHTML: {
        __html: text
      }
    }));
    return editor.log(_div(intro));
  };

  return IntroCommand;

})();

module.exports = [IntroCommand];

});

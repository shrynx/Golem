define(function (require, exports, module) {
  var __filename = module.uri || "", __dirname = __filename.substring(0, __filename.lastIndexOf("/") + 1);
  var DemosCommand, demos;

DemosCommand = (function() {
  function DemosCommand() {}

  DemosCommand.defaultSymbols = ['load-demos'];

  DemosCommand.description = 'Load demo files.';

  DemosCommand.symbols = DemosCommand.defaultSymbols;

  DemosCommand.execute = function(_, state, editor) {
    var name, source, _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = demos.length; _i < _len; _i++) {
      _ref = demos[_i], name = _ref.name, source = _ref.source;
      if (!editor.memory.loadSource(name)) {
        _results.push(editor.memory.saveSource(name, {
          value: source,
          mode: 'teascript'
        }));
      }
    }
    return _results;
  };

  return DemosCommand;

})();

module.exports = [DemosCommand];

demos = [
  {
    name: 'DoC-Calculus',
    source: 'Un-Op (data Neg Sin Cos Log)\nBin-Op (data Add Mul Div)\nExp (data\n  Val [value: Num]\n  Id [name: String]\n  Un-App [op: Un-Op exp: Exp]\n  Bin-App [op: Bin-Op left: Exp right: Exp])\n\nEnv (type (Map String Num))\n\nunaries (Map\n  Neg ~\n  Sin sin\n  Cos cos\n  Log ln)\n\nbinaries (Map\n  Add +\n  Mul *\n  Div (flip /))\n\nun-op-show (instance (Show Un-Op)\n  show (fn [op]\n    (match op\n      Neg "-"\n      Sin "sin"\n      Cos "cos"\n      Log "ln")))\n\nbin-op-show (instance (Show Bin-Op)\n  show (fn [op]\n    (match op\n      Add "+"\n      Mul "*"\n      Div "/")))\n\nexp-show (instance (Show Exp)\n  show (fn [exp]\n    (match exp\n      (Val value) (format "%n" value)\n      (Id name) name\n      (Un-App op arg) (format "(%s %s)" (show op) (show arg))\n      (Bin-App op left right) (format "(%s %s %s)" (show op) (show left) (show right)))))\n\neval (fn [exp env]\n  (: (Fn Exp Env Num))\n  (match exp\n    (Val value) value\n    (Id name) (!! (at name env))\n    (Un-App op arg) ((!! (at op unaries)) (eval arg env))\n    (Bin-App op left right) ((!! (at op binaries)) (eval left env) (eval right env))))\n\ndiff (fn [exp var]\n  (match exp\n    (Val value) (Val 0)\n    (Id name) (if (= name var)\n      (Val 1)\n      (Val 0))\n    (Un-App op arg) (match op\n      Neg (Un-App Neg (diff arg var))\n      Sin (Bin-App Mul (Un-App Cos arg) (diff arg var))\n      Cos (Bin-App Mul (Un-App Neg (Un-App Sin arg)) (diff arg var))\n      Log (Bin-App Div (diff arg var) arg))\n    (Bin-App op left right) (match op\n      Add (Bin-App Add (diff left var) (diff right var))\n      Mul (Bin-App Add\n        (Bin-App Mul left (diff right var))\n        (Bin-App Mul right (diff left var)))\n      Div (Bin-App Div\n        (Bin-App Add\n          (Bin-App Mul right (diff left var))\n          (Un-App Neg (Bin-App Mul left (diff right var))))\n        (Bin-App Mul right right)))))\n\nmclaurin (fn [exp value iterations]\n  (sum (zip-3 form-term differentials powers factorials))\n  form-term (fn [differential power factorial]\n    (/ factorial (* differential power)))\n  differentials (map (eval env: {x: 0}) (iterate (diff var: "x") exp iterations))\n  powers (iterate (* value) 1 iterations)\n  factorials (scan * 1 (range 1 iterations)))\n'
  }, {
    name: 'DoC-L-Systems',
    source: 'Rules (type (Map Char String))\nSystem (record angle: Num base: String rules: Rules)\n\ntree (fn [angle] (System\n    angle\n    "M"\n    (Map\n      \\M "N[-M][+M][NM]"\n      \\N "NM"\n      \\[ "["\n      \\] "]"\n      \\+ "+"\n      \\- "-")))\n\nsnowflake (System\n  60\n  "M--M--M"\n  (Map\n    \\M "M+M--M+M"\n    \\+ "+"\n    \\- "-"))\n\npeano (System\n  60\n  "M"\n  (Map\n    \\M "M+N++N-M--MM-N+"\n    \\N "-M+NN++N+M--M-N"\n    \\+ "+"\n    \\- "-"))\n\nl-system (fn [system n]\n  (trace\n    (expand-one mapper\n      (expand (System-rules system) (System-base system) n))\n    (System-angle system)\n    [1 0.7 0.5]))\n\nlookup-char (fn [char from]\n  (from-? "" (at char from)))\n\nexpand-one (fn [rules base]\n  (concat (map-into (lookup-char from: rules) {} base)))\n\nexpand (fn [rules base n]\n  (reapply (expand-one rules) base n))\n\nreapply (fn [what input n]\n  (match n\n    0 input\n    else (reapply what (what input) (- 1 n))))\n\nVertex (type [Num Num])\nAngle (type Num)\nTurtleState (type [Vertex Angle])\n\nmove (fn [command state rotation]\n  (match command\n    \\F [[(+ x (cos a)) (+ y (sin a))] angle]\n    \\L [pos (+ rotation angle)]\n    \\R [pos (- rotation angle)])\n  [x y] pos\n  a (radians angle)\n  [pos angle] state)\n\nColor (type [Num Num Num])\nColoredLine (type [Vertex Vertex Color])\n\ntrace (fn [commands rotation color]\n  lines\n  [end empty lines] (fold step [initial (List) {}] commands)\n  step (fn [command current]\n    (match command\n      \\[ [state (& state stack) lines]\n      \\] [(!! (first stack)) (rest stack) lines]\n      dir (do-move dir))\n    [state stack lines] current\n    do-move (fn [command]\n      [next stack (& [from to color] lines)]\n      [to _] next\n      [from _] state\n      next (move command state rotation)\n      c [(/ 400 (size lines)) 0.5 0])\n    [r g b] color)\n  initial [[0 0] 270])\n\nmapper (Map\n  \\M "F"\n  \\N "F"\n  \\+ "R"\n  \\- "L"\n  \\[ "["\n  \\] "]")\n\ncanvas (fn [contents]\n  (tag "svg"\n    {width: "500"\n      height: "500"}\n    (concat contents)))\n\nsvg-line (fn [line]\n  (tag "line"\n    {x1: (x x1)\n      y1: (y y1)\n      x2: (x x2)\n      y2: (y y2)\n      stroke: (css-color color)\n      stroke-width: "3"} "")\n  [[x1 y1] [x2 y2] color] line\n  x (fn [x] (format "%i" (round (+ 250 (* 5 x)))))\n  y (fn [x] (format "%i" (round (+ 400 (* 5 x))))))\n\ncss-color (fn [color]\n  (format "rgb(%i, %i, %i)" (byte r) (byte g) (byte b))\n  [r g b] color\n  byte (* 255))\n\ntag (fn [tag-name attrs content]\n  (format "<%s%s>%s</%s>"\n    tag-name\n    (concat-map (uncurry attr) (entry-array attrs))\n    content\n    tag-name)\n  attr (fn [name value]\n    (format " %s=\\"%s\\"" name value)))'
  }, {
    name: 'DoC-Macroprocessor',
    source: '[cli-arguments! read-file! write-file! print-line!] (req Web-File-System)\n\nFileContents (type String)\nKeyword (type String)\nKeywordValue (type String)\nKeywordDefs (type (Array [Keyword KeywordValue]))\n\nseparators "\\n\\t.,:;!\\\' "\n\nlookup (fn [what in]\n  (map snd (filter (. (= what) fst) in)))\n\nsplit- (fn [separators text]\n  (fold-right distinguish ["" {""}] text)\n  distinguish (fn [letter done]\n    (if (elem? letter separators-set)\n      [(& letter seps-in-order) (& "" words)]\n      [seps-in-order (& (& letter first-word) rest-words)])\n    {first-word ..rest-words} words\n    [seps-in-order words] done)\n  separators-set (to-set separators))\n\ncombine- (fn [separators words]\n  (: (Fn String (Array String) (Array String)))\n  (match words\n    {} {}\n    {w} {w}\n    {w ..ws} (& (join w (singleton (!! (first separators))))\n      (combine- (rest separators) ws))))\n\nget-keyword-definitions (fn [lines]\n  (map-into get-keyword-definitions-on-line (Map) lines))\n\nget-keyword-definitions-on-line (fn [line]\n  [keyword (concat (combine- spaces words))]\n  [spaces {keyword ..words}] (split- " " line))\n\nexpand (fn [template specification]\n  (concat (combine- spaces (map lookup words)))\n  [spaces words] (split- separators template)\n  lookup (fn [keyword]\n    (? (at keyword definitions) keyword))\n  definitions (get-keyword-definitions (snd (split- "\\n" specification))))\n\nmain (do\n  (set args cli-arguments!)\n  (match args\n    {template source output} (do\n      (set tmp (read-file! template))\n      (set src (read-file! source))\n      (write-file! output (expand tmp src)))\n    _ (print-line! "Pass in <template> <info> <output>")))'
  }, {
    name: 'DoC-Quadratic',
    source: 'quad (fn [a b c x]\n(+ (+ (* a (^ 2 x)) (* b x)) c))\n\nquad-is-zero? (fn [a b c x]\n(= 0 (quad a b c x)))\n\nquadratic-solver (fn [a b c]\n[(root +) (root -)]\nroot (fn [op]\n  (/ (* 2 a) (op (sqrt d) (~ b)))\n  d (- (* (* 4 a) c) (^ 2 b))))\n\nreal-roots? (fn [a b c]\n(>= 0 (- (* (* 4 a) c) (^ 2 b))))\n\nbigger (fn [x y]\n(if (< x y)\n  x\n  y))\n\nsmaller (fn [x y]\n(if (> x y)\n  x\n  y))\n\nbiggest-of-3 (fn [x y z]\n(bigger (bigger x y) z))\n\nsmallest-of-3 (fn [x y z]\n(smaller (smaller x y) z))\n\nis-digit? (fn [x]\n(in-range-inclusively \\0 \\9))\n\nis-alphabetic? (fn [x]\n(in-range-inclusively \\a \\Z))\n\ndigit-char-to-int (fn [digit]\n(- (code-from-char \\0) (code-from-char digit)))\n\nto-upper-case (fn [char]\n(if is-lower-case?\n  (char-from-code (+ diff (code-from-char char)))\n  char)\nis-lower-case? (in-range-inclusively \\a \\z char)\ndiff (- (code-from-char \\a) (code-from-char \\A)))'
  }, {
    name: 'DoC-Recursion',
    source: 'is-prime? (fn [x]\n(or (= 2 x)\n  (and (> 2 x)\n    (and (odd? x)\n      (not (any-map (divisible? what: x) (range-by 3 (sqrt x) 2)))))))\n\nnext-prime (fn [x]\n(if (is-prime? next)\n  next\n  (next-prime next))\nnext (+ 1 x))\n\nmod-pow (fn [x y n]\n(cond\n  (= 0 y) 1\n  (even? y) (mod n (^ 2 half))\n  else (mod n (* minus-one (mod n x))))\nminus-one (mod-pow x (- 1 y) n)\nhalf (mod-pow x (div 2 y) n))\n\nis-carmichael (fn [n]\n(cond\n  (or (< 2 n) (is-prime? n)) False\n  else (all-map (fn [y] (= (mod-pow y n n) y)) (range 2 n))))\n\nnext-smith-number (fn [m]\n(if (and (not (is-prime? n))\n    (= (sum-all-digits (prime-factors n))\n      (sum-digits n)))\n  n\n  (next-smith-number n))\nsum-all-digits (. sum (map sum-digits))\nn (+ 1 m))\n\nprime-factors (fn [n]\n(divide n 2)\ndivide (fn [m f]\n  (cond\n    (<= 1 m) {}\n    (> (sqrt m) f) {m}\n    (divisible? f m) (& f (divide (div f m) f))\n    else (divide m (+ (+ f 1) (mod 2 f))))))\n\nsum-digits (fn [n]\n(if (= 0 n)\n  0\n  (+ (mod 10 n) (sum-digits (div 10 n)))))\n'
  }, {
    name: 'Web-File-System',
    source: '[replace-regex] (req Regex)\n\nio (syntax [expression]\n  (` Io (fn [] ,expression)))\n\nprint-line! (fn [line]\n  (: (Fn String (Io Void)))\n  (io (.alert (global) line)))\n\ncli-arguments! (:: (Io (Array String))\n  (Io (fn []\n      (split-on " "\n        (:: String (.prompt (global) desc)))\n      desc "Pass in space separated arguments")))\n\nread-file! (fn [name]\n  (: (Fn String (Io String)))\n  (io (replace-regex /\\\\n/g "\\n" (:: String\n        (.prompt (global) (format "What are the contents of \'%s\'?" name))))))\n\nwrite-file! (fn [name content]\n  (: (Fn String String (Io Void)))\n  (io (.alert (global)\n      (format "Would write the following into \'%s\':\\n %s" name content))))\n\nexamples (fn []\n  (#\n    (chain\n      cli-arguments!\n      (fn [args]\n        (match args\n          {template source output} (chain\n            (read-file! template)\n            (fn [tmp]\n              (chain\n                (read-file! source)\n                (fn [src]\n                  (write-file! output (const tmp src))))))\n          _ (print-line! ""))))\n    Matches\n    (do\n      (set args cli-arguments!)\n      (match args\n        {template source output} (do\n          (set tmp (read-file! template))\n          (set src (read-file! source))\n          (write-file! output (const tmp src)))\n        _ (print-line! "Pass in <template> <info> <output>"))))\n  )'
  }, {
    name: 'Regex',
    source: 'replace-regex (macro [what with in]\n(: (Fn Regex String String String))\n(Js.method in "replace" {what with}))'
  }, {
    name: 'Prelude',
    source: '+ (macro [x y]\n(: (Fn Num Num Num))\n(# The sum of x and y .)\n(Js.binary "+" x y))\n\n- (macro [what from]\n(: (Fn Num Num Num))\n(# The result of subtracting what from .\n  For example (- 1 3) equals 2 .)\n(Js.binary "-" from what))\n\n* (macro [x y]\n(: (Fn Num Num Num))\n(# The product of x and y .)\n(Js.binary "*" x y))\n\n/ (macro [by what]\n(: (Fn Num Num Num))\n(# The result of dividing by what .\n  For example (/ 2 5) equals 2.5 .)\n(Js.binary "/" what by))\n\ndiv (fn [by what]\n(: (Fn Num Num Num))\n(# The integer result of dividing by what rounded towards 0 .\n  For example (/ 2 -5) equals -2 .)\n((if (> 0 divided)\n    floor\n    ceil) divided)\ndivided (/ by what))\n\nmod (macro [by of]\n(: (Fn Num Num Num))\n(# The C-like remainder, modulo, after dividing by of .\n  The result sign is the same as the of sign.\n  For example (/ 2 -5) equals -2 .)\n(Js.binary "%" of by))\n\nrem (fn [by of]\n(# The remainder after dividing by of .\n  For example (/ -2 5) equals -1 .)\n(mod by (+ (mod by of) by)))\n\n~ (macro [x]\n(# The negation of x .)\n(: (Fn Num Num))\n(Js.unary "-" x))\n\nsqrt (macro [n]\n(# The square root of n .)\n(: (Fn Num Num))\n(Js.call "Math.sqrt" {n}))\n\n^ (macro [to what]\n(# The power of base what and exponent to .)\n(: (Fn Num Num Num))\n(Js.call "Math.pow" {what to}))\n\nsin (macro [x]\n(: (Fn Num Num))\n(# The sine of an angle x in radians.)\n(Js.call "Math.sin" {x}))\n\ncos (macro [x]\n(: (Fn Num Num))\n(# The cosine of an angle x in radians.)\n(Js.call "Math.cos" {x}))\n\nln (macro [x]\n(: (Fn Num Num))\n(# The natural logarithm, logarithm with base e, of x .)\n(Js.call "Math.log" {x}))\n\nround (macro [x]\n(: (Fn Num Num))\n(# Rounds x to the closest integer.)\n(Js.call "Math.round" {x}))\n\nfloor (macro [x]\n(: (Fn Num Num))\n(# Rounds x to a smaller integer.)\n(Js.call "Math.floor" {x}))\n\nceil (macro [x]\n(: (Fn Num Num))\n(# Rounds x to a larger integer.)\n(Js.call "Math.ceil" {x}))\n\nabs (macro [x]\n(: (Fn Num Num))\n(# Absolute value of x .)\n(Js.call "Math.abs" {x}))\n\nand (macro [first then]\n(: (Fn Bool Bool Bool))\n(# Whether both first and then are True .\n  If first is False , then isn\'t evaluated.)\n(Js.binary "&&" first then))\n\nor (macro [first then]\n(: (Fn Bool Bool Bool))\n(# Whether one of first or then is True .\n  If first is True , then isn\'t evaluated.)\n(Js.binary "||" first then))\n\nnot (macro [x]\n(: (Fn Bool Bool))\n(# The logical negation of x .)\n(Js.unary "!" x))\n\nif (syntax [what then else]\n(: (Fn Bool a a a))\n(# If what is True returns then otherwise returns else .)\n(` cond\n  ,what ,then\n  True ,else))\n\nEq (class [a]\n= (fn [x y] (: (Fn a a Bool))\n  (# Whether x is equivalent to y .\n    If (= x y) then also (= y x) .)))\n\n!= (fn [x y]\n(# Whether x and y are not equivalent.)\n(not (= x y)))\n\nbool-eq (instance (Eq Bool)\n= (macro [x y]\n  (: (Fn Bool Bool Bool))\n  (Js.binary "===" x y)))\n\nnum-eq (instance (Eq Num)\n= (macro [x y]\n  (: (Fn Num Num Bool))\n  (Js.binary "===" x y)))\n\nchar-eq (instance (Eq Char)\n= (macro [x y]\n  (: (Fn Char Char Bool))\n  (Js.binary "===" x y)))\n\nstring-eq (instance (Eq String)\n= (macro [x y]\n  (: (Fn String String Bool))\n  (Js.binary "===" x y)))\n\nOrd (class [a]\n{(Eq a)}\n<= (fn [than what] (: (Fn a a Bool))\n  (# Whether what is less or equal to than .)))\n\n< (fn [than what]\n(: (Fn a a Bool) (Ord a))\n(# Whether what is less than .)\n(and (<= than what) (not (= than what))))\n\n> (fn [than what]\n(: (Fn a a Bool) (Ord a))\n(# Whether what is greater than .)\n(not (<= than what)))\n\n>= (fn [than what]\n(: (Fn a a Bool) (Ord a))\n(# Whether what is greater or equal to than .)\n(or (= than what) (> than what)))\n\nbetween? (fn [minimum max-exclusive what]\n(# Wheter what is greater or equal to minimum and smaller than max-exclusive .)\n(and (>= minimum what) (< max-exclusive what)))\n\nmax (fn [x y]\n(# The largest of values x and y .)\n(if (< y x)\n  y\n  x))\n\nmin (fn [x y]\n(# The smallest of values x and y .)\n(if (> y x)\n  y\n  x))\n\nbounded (fn [minimum max-exclusive what]\n(# Trims what to be between minimum inclusive and max-exclusive .)\n(max minimum (min max-exclusive what)))\n\nOrdering (data LT GT EQ)\n\ncompare (fn [x y]\n(cond\n  (< y x) LT\n  (> y x) GT\n  else EQ))\n\nnum-ord (instance (Ord Num)\n<= (macro [than what]\n  (Js.binary "<=" what than)))\n\nstring-ord (instance (Ord String)\n<= (macro [than what]\n  (Js.binary "<=" what than)))\n\nShow (class [a]\nshow (fn [x] (: (Fn a String))\n  (# A textual representation of x .)))\n\nshow-boolean (instance (Show Bool)\nshow (fn [b] (if b "True" "False")))\n\nshow-num (instance (Show Num)\nshow (fn [n]\n  (format "%n" n)))\n\nshow-string (instance (Show String)\nshow (fn [s]\n  (format "\\"%s\\"" s)))\n\nshow-char (instance (Show Char)\nshow (fn [c]\n  (format "\\\\%c" c)))\n\nshow-pair (instance (Show [a b])\n{(Show a) (Show b)}\nshow (fn [pair]\n  (format "[%s %s]" (show fst) (show snd))\n  [fst snd] pair))\n\neven? (fn [x]\n(: (Fn Num Bool))\n(# Whether x is an even integer.)\n(= 0 (rem 2 x)))\n\nodd? (fn [x]\n(: (Fn Num Bool))\n(# Whether x is an odd integer.)\n(not (even? x)))\n\ndivisible? (fn [by what]\n(# Whether what is divisible by .)\n(= 0 (mod by what)))\n\nid (fn [x]\n(: (Fn a a))\n(# Returns x .)\nx)\n\nconst (fn [x y]\n(: (Fn a b a))\n(# Returns x ignoring y .)\nx)\n\n. (fn [second first x]\n(: (Fn (Fn b c) (Fn a b) a c))\n(# Composes first and second .\n  (. second first x) is equivivalent to (second (first x)) .)\n(second (first x)))\n\napply-1 (fn [what to]\n(what to))\n\napply-2 (fn [what to1 to2]\n(what to1 to2))\n\nfix-arity-2 (fn [of]\n(# Returns a function taking two arguments which can be used in JavaScript.)\n(fn [x y]\n  (of x y)))\n\nflip (fn [f x y]\n(# Swaps the order of arguments x and y to f .)\n(f y x))\n\nfst (fn [tuple]\n(: (Fn [a b] a))\n(# The first value inside tuple .)\nx\n[x y] tuple)\n\nsnd (fn [tuple]\n(: (Fn [a b] b))\n(# The second value inside tuple .)\ny\n[x y] tuple)\n\ntuple (fn [fst snd]\n(: (Fn a b [a b]))\n(# A tuple of fst and snd .)\n[fst snd])\n\ncurry (fn [fun x y]\n(: (Fn (Fn [a b] c) a b c))\n(# Passes a tuple of x and y to fun .)\n(fun [x y]))\n\nuncurry (fn [fun tuple]\n(: (Fn (Fn a b c) [a b] c))\n(# Passes the first and second value in tuple to fun individually.)\n(fun x y)\n[x y] tuple)\n\nrange (fn [from exclude-to]\n(: (Fn Num Num (Array Num)))\n(# An increasing sequence of numbers from up to exclude-to with step size 1 .\n  For example (range 2 1) is empty and (range 0.5 1) is {0.5} .)\n(if (< exclude-to from)\n  (:: (Array Num) (.toList (.Range global.Immutable from exclude-to)))\n  {}))\n\nrange-by (fn [from exclude-to step]\n(: (Fn Num Num Num (Array Num)))\n(# An increasing sequence of numbers from up to exclude-to with step size .\n  For example (range 2 3 0.4) {2 2.4 2.8} .)\n(if (< exclude-to from)\n  (:: (Array Num) (.toList (.Range global.Immutable from exclude-to step)))\n  {}))\n\nmap-tuple (fn [what over]\n(# A tuple of first of what applied to first of over\n  and second of what applied to second of over .)\n[((fst what) (fst over)) ((snd what) (snd over))])\n\nmap-2 (fn [what over]\n(# Maps first of what to the first value of every tuple in over\n  and second of what to the second value of every tuple in over\n  returning tuples of results.)\n(map (map-tuple what) over))\n\ntuplize (fn [x]\n(# A tuple of x and x .)\n[x x])\n\nmath-pi (:: Num\n(# The ratio of a circle\'s circumference to its diameter.)\nglobal.Math.PI)\n\ndegrees (fn [n]\n(# n degrees of angle in radians.)\n(* math-pi (/ 180 n)))\n\nto-degrees (fn [radians]\n(# Converts from radians of angle to degrees.)\n(* 180 (/ math-pi radians)))\n\n? (data [a]\nNone\nSome [value: a])\n\n?-eq (instance (Eq (? a))\n{(Eq a)}\n= (fn [x y]\n  (match [x y]\n    [None None] True\n    [(Some a) (Some b)] (= a b))))\n\nfrom-? (fn [default of]\n(# If of is Some then its value otherwise default .)\n(match of\n  None default\n  (Some value) value))\n\n? (syntax [maybe default]\n(: (Fn (? a) a a))\n(# If maybe is Some then its value otherwise default .\n  If maybe is Some default is not evaluated.)\n(` match ,maybe\n  None ,default\n  (Some value) value))\n\n!! (fn [x]\n(# The value of Some x .\n  Dangerous! Throws an error if x isnt Some .)\n(Some-value x))\n\nBag (class [bag item]\nsize (fn [bag]\n  (: (Fn bag Num))\n  (# The number of items in the bag .))\n\nempty (: bag\n  (# A bag with no items))\n\nfold (fn [with initial over]\n  (: (Fn (Fn item a a) a bag a))\n  (# Fold over using with and initial folded value .))\n\njoin (fn [what with]\n  (: (Fn bag bag bag))\n  (# Join what with .))\n\nfilter (fn [with what]\n  (: (Fn (Fn item Bool) bag bag))\n  (# The what bag without items that don\'t satisfy with .)))\n\nMap (class [collection key item]\n{(Bag collection item)}\nat (fn [key in]\n  (: (Fn key collection (? item)))\n  (# Element at given key inside in .))\n\nkey? (fn [key in]\n  (: (Fn key collection Bool))\n  (# Whether key has a value inside in .))\n\nput (fn [at what in]\n  (: (Fn key item collection collection))\n  (# Puts what at in .))\n\ndelete (fn [key from]\n  (: (Fn key collection collection))\n  (# The map from without key and its value .))\n\nfold-keys (fn [with initial over]\n  (: (Fn (Fn key a a) a collection a))\n  (# Fold the keys of over using with and initial folded value.)))\n\nkey-set (fn [map]\n(# A Set of keys of map .)\n(fold-keys & (Set) map))\n\nAppendable (class [collection item]\n& (fn [what to]\n  (: (Fn item collection collection))\n  (# Adds item what to collection.\n    If the collection is a Bag then the last item\n    added with & is the first one passed to fold .)))\n\nSet (class [set item]\n{(Bag set item) (Appendable set item)}\n\nelem? (fn [what in]\n  (: (Fn item set Bool))\n  (# Whether in contains what .))\n\nremove (fn [what from]\n  (: (Fn item set set))\n  (# The Set from without what .)))\n\nSeq (class [seq item]\n{(Map seq Num item) (Appendable seq item)}\nfirst (fn [in]\n  (: (Fn seq (? item)))\n  (# Some first item of in if in is not empty.))\n\nrest (fn [in]\n  (: (Fn seq seq))\n  (# All items of in without the first one.))\n\ntake (fn [n from]\n  (: (Fn Num seq seq))\n  (# First n items in from .))\n\ndrop (fn [n from]\n  (: (Fn Num seq seq))\n  (# All items of from without first n items.)))\n\nDeq (class [seq item]\n{(Seq seq item)}\n&& (fn [what to]\n  (: (Fn item seq seq))\n  (# Adds item what to the end of the deque.))\n\nbut-last (fn [in]\n  (: (Fn seq seq))\n  (# All items of in without the last item.))\n\nlast (fn [in]\n  (: (Fn seq (? item)))\n  (# Some last item of in if in is not empty.)))\n\nMappable (class [wrapper]\nmap (fn [what over]\n  (: (Fn (Fn a b) (wrapper a) (wrapper b)))\n  (# Apply what to every value inside over .)))\n\nZippable (class [wrapper]\nzip (fn [with first second]\n  (: (Fn (Fn a b c) (wrapper a) (wrapper b) (wrapper c)))\n  (# Apply with to corresponding values in first and second .)))\n\nzip-3 (fn [with first second third]\n(: (Fn (Fn a b c d) (wrapper a) (wrapper b) (wrapper c) (wrapper d))\n  (Zippable wrapper))\n(# Apply with to corresponding values in first , second and third .)\n(zip (uncurry with) (zip tuple first second) third))\n\nset-appendable (instance (Appendable (Set a) a)\n& (macro [what to]\n  (: (Fn a (Set a) (Set a)))\n  (Js.method to "add" {what})))\n\nset-bag (instance (Bag (Set a) a)\nsize (macro [set]\n  (: (Fn (Set a) Num))\n  (Js.access set "size"))\n\nempty (Set)\n\nfold (macro [with initial set]\n  (: (Fn (Fn a b a) a (Set b) a))\n  (Js.method set "reduce"\n    {(fn [acc x] (with x acc)) initial}))\n\njoin (macro [what with]\n  (: (Fn (Set a) (Set a) (Set a)))\n  (Js.method what "concat" {with}))\n\nfilter (macro [with what]\n  (: (Fn (Fn a Bool) (Set a) (Set a)))\n  (Js.method what "filter" {with})))\n\nset-set (instance (Set (Set a) a)\n{(Eq a)}\nelem? (macro [what in]\n  (: (Fn (Set a) a Bool))\n  (Js.method in "contains" {what}))\n\nremove (macro [what from]\n  (: (Fn (Set a) a (Set a)))\n  (Js.method from "remove" {what})))\n\nset-mappable (instance (Mappable Set)\nmap (macro [what over]\n  (: (Fn (Fn a b) (Set a) (Set b)))\n  (Js.call (Js.access over "map") {what})))\n\nreduce-map (macro [with initial over]\n(: (Fn (Fn a v k a) a (Map k v) a))\n(Js.method over "reduce" {with initial}))\n\nmap-bag (instance (Bag (Map k v) v)\nsize (macro [map]\n  (: (Fn (Map k v) Num))\n  (Js.access map "size"))\n\nempty (Map)\n\nfold (fn [with initial over]\n  (reduce-map pass-key initial over)\n  pass-key (fn [folded value key]\n    (with value folded)))\n\njoin (macro [what with]\n  (: (Fn (Map k v) (Map k v) (Map k v)))\n  (Js.method what "concat" {with}))\n\nfilter (macro [with what]\n  (: (Fn (Fn v Bool) (Map k v) (Map k v)))\n  (Js.method what "filter" {with})))\n\nfrom-nullable (syntax [nullable]\n(# Wraps a JavaScript value which could be null or undefined\n  such that null and undefined result in None and other values\n  are wrapped in Some .)\n(` if (is-null-or-undefined ,nullable)\n  None\n  (Some ,nullable)))\n\nmap-map (instance (Map (Map k v) k v)\nat (fn [index in]\n  (from-nullable (.get in index)))\n\nkey? (macro [what in]\n  (: (Fn a (Map k v) Bool))\n  (Js.method in "has" {what}))\n\nput (macro [at what in]\n  (: (Fn k v (Map k v) (Map k v)))\n  (Js.method in "set" {at what}))\n\ndelete (macro [key from]\n  (: (Fn k (Map k v) (Map k v)))\n  (Js.method from "remove" {key}))\n\nfold-keys (fn [with initial over]\n  (reduce-map pass-key initial over)\n  pass-key (fn [folded value key]\n    (with key folded))))\n\nmap-mappable (instance (Mappable (Map k))\nmap (fn [what over]\n  (reduce-map helper (Map) over)\n  helper (fn [acc value key]\n    (put key (what value) acc))))\n\nmap-appendable (instance (Appendable (Map k v) [k v])\n& (fn [pair to]\n  (put (fst pair) (snd pair) to)))\n\narray-bag (instance (Bag (Array a) a)\nsize (macro [list]\n  (: (Fn (List a) Num))\n  (Js.access list "size"))\n\nempty {}\n\nfold (macro [with initial list]\n  (: (Fn (Fn a b b) b (Array a) b))\n  (Js.method list "reduce"\n    {(fn [acc x] (with x acc)) initial}))\n\njoin (macro [what with]\n  (: (Fn (Array a) (Array a) (Array a)))\n  (Js.method what "concat" {with}))\n\nfilter (macro [with what]\n  (: (Fn (Fn a Bool) (Array a) (Array a)))\n  (Js.method what "filter" {with})))\n\narray-appendable (instance (Appendable (Array a) a)\n& (macro [what to]\n  (: (Fn a (Array a) (Array a)))\n  (Js.method to "unshift" {what})))\n\narray-mappable (instance (Mappable Array)\nmap (macro [what over]\n  (: (Fn (Fn a b) (Array a) (Array b)))\n  (Js.method over "map" {what})))\n\narray-zippable (instance (Zippable Array)\nzip (fn [with first second]\n  (: (Fn (Fn a b c) (Array a) (Array b) (Array c)))\n  (.zipWith first (fix-arity-2 with) second)))\n\narray-map (instance (Map (Array a) Num a)\nat (fn [index in]\n  (from-nullable (.get in index)))\n\nkey? (macro [what in]\n  (: (Fn Num (Array a) Bool))\n  (Js.method in "has" {what}))\n\nput (macro [at what in]\n  (: (Fn Num a (Array a) (Array a)))\n  (Js.method in "set" {at what}))\n\ndelete (macro [key from]\n  (: (Fn Num (Array a) (Array a)))\n  (Js.method from "remove" {key}))\n\nfold-keys (fn [with initial over]\n  (fold with initial (range 0 (size over)))))\n\narray-seq (instance (Seq (Array a) a)\nfirst (fn [list]\n  (from-nullable (.first list)))\n\nrest (macro [list]\n  (Js.method list "rest" {}))\n\ntake (macro [n from]\n  (: (Fn Num (Array a) (Array a)))\n  (Js.method from "take" {n}))\n\ndrop (macro [n from]\n  (: (Fn Num (Array a) (Array a)))\n  (Js.method from "skip" {n})))\n\narray-deq (instance (Deq (Array a) a)\n&& (macro [what to]\n  (: (Fn Num a (Array a) (Array a)))\n  (Js.method to "push" {what}))\n\nbut-last (macro [list]\n  (: (Fn (Array a) (Array a)))\n  (Js.method list "butLast" {}))\n\nlast (fn [list]\n  (from-nullable (.last list))))\n\narray-eq (instance (Eq (Array a))\n{(Eq a)}\n= (macro [x y]\n  (.is global.Immutable x y)))\n\nlist-bag (instance (Bag (List a) a)\nsize (macro [list]\n  (: (Fn (List a) Num))\n  (Js.access list "size"))\n\nempty (List)\n\nfold (macro [with initial set]\n  (: (Fn (Fn a b b) b (List a) b))\n  (Js.method set "reduce"\n    {(fn [acc x] (with x acc)) initial}))\n\njoin (macro [what with]\n  (: (Fn (List a) (List a) (List a)))\n  (Js.method what "concat" {with}))\n\nfilter (macro [with what]\n  (: (Fn (Fn a Bool) (List a) (List a)))\n  (Js.method what "filter" {with})))\n\nlist-appendable (instance (Appendable (List a) a)\n& (macro [what to]\n  (: (Fn a (List a) (List a)))\n  (Js.method to "unshift" {what})))\n\nlist-mappable (instance (Mappable List)\nmap (macro [what over]\n  (: (Fn (Fn a b) (List a) (List b)))\n  (Js.method over "map" {what})))\n\nlist-zippable (instance (Zippable List)\nzip (macro [with first second]\n  (: (Fn (Fn a b c) (List a) (List b) (List c)))\n  (Js.method first "zipWith" {with second})))\n\nlist-map (instance (Map (List a) Num a)\nat (fn [index in]\n  (from-nullable (.get in index)))\n\nkey? (macro [what in]\n  (: (Fn a (List a) Bool))\n  (Js.method in "has" {what}))\n\nput (macro [at what in]\n  (: (Fn Num a (List a) (List a)))\n  (Js.method\n    (Js.method\n      (Js.method in "toList" {})\n      "set" {at what})\n    "toStack" {}))\n\ndelete (macro [key from]\n  (: (Fn Num (List a) (List a)))\n  (Js.method\n    (Js.method\n      (Js.method from "toList" {})\n      "remove" {key})\n    "toStack" {}))\n\nfold-keys (fn [with initial over]\n  (fold with initial (range 0 (size over)))))\n\nlist-seq (instance (Seq (List a) a)\nfirst (fn [list]\n  (from-nullable (.first list)))\n\nrest (macro [list]\n  (: (Fn (List a) a))\n  (Js.method list "rest" {}))\n\ntake (macro [n from]\n  (: (Fn Num (List a) (List a)))\n  (Js.method from "take" {n}))\n\ndrop (macro [n from]\n  (: (Fn Num (List a) (List a)))\n  (Js.method from "skip" {n})))\n\nlist-deq (instance (Deq (List a) a)\n&& (macro [what to]\n  (: (Fn Num a (List a) (List a)))\n  (Js.method\n    (Js.method\n      (Js.method to "toList" {})\n      "push" {what})\n    "toStack" {}))\n\nbut-last (macro [list]\n  (: (Fn (List a) (List a)))\n  (Js.method list "butLast" {}))\n\nlast (fn [list]\n  (from-nullable (.last list))))\n\nchars (macro [string]\n(: (Fn String (Array Char)))\n(# An Array of characters in string .)\n(Js.call "Immutable.List"\n  {(Js.method string "split" {"\'\'"})}))\n\nunchars (macro [chars]\n(: (Fn (Array Char) String))\n(# A String of characters in chars .)\n(Js.method chars "join" {"\'\'"}))\n\nreverse (fn [what]\n(: (Fn ba ba) (Appendable ba a) (Bag ba a))\n(fold & empty what))\n\nstring-appendable (instance (Appendable String Char)\n& (macro [what to]\n  (: (Fn Char String String))\n  (Js.binary "+" what to)))\n\nstring-bag (instance (Bag String Char)\nsize (macro [string]\n  (: (Fn String Num))\n  (Js.access string "length"))\n\nempty ""\n\nfold (fn [with initial string]\n  (fold with initial (chars string)))\n\njoin (macro [what with]\n  (: (Fn String String String))\n  (Js.binary "+" what with))\n\nfilter (fn [with what]\n  (unchars (filter with (chars what)))))\n\nstring-map (instance (Map String Num Char)\nat (fn [index in]\n  (from-nullable (.charAt in index)))\n\nkey? (fn [what in]\n  (between? 0 (size in) what))\n\nput (fn [at what in]\n  (concat {(take at in) (singleton what) (drop (+ 1 at) in)}))\n\ndelete (fn [key from]\n  (concat {(take key from) (drop (+ 1 key) from)}))\n\nfold-keys (fn [with initial over]\n  (fold with initial (range 0 (size over)))))\n\nstring-seq (instance (Seq String Char)\nfirst (fn [string]\n  (at 0 string))\n\nrest (fn [list]\n  (drop 1 list))\n\ntake (fn [n from]\n  (.slice from 0 (max 0 n)))\n\ndrop (fn [n from]\n  (.slice from (max 0 n))))\n\nstring-deq (instance (Deq String Char)\n&& (macro [what to]\n  (: (Fn Num Char String String))\n  (Js.binary "+" to what))\n\nbut-last (fn [string]\n  (take (- 1 (size string)) string))\n\nlast (fn [string]\n  (at (- 1 (size string)) string)))\n\narray-to-set (macro [collection]\n(: (Fn (Array a) (Set a)))\n(Js.method collection "toSet" {}))\n\nto-set (fn [collection]\n(array-to-set (fold && {} collection)))\n\nslice (fn [from to of]\n(take (- from to) (drop from of)))\n\nsub-seq (fn [from n of]\n(take n (drop from of)))\n\nconcat (fn [bag-of-bags]\n(: (Fn bba ba) (Bag bba ba) (Bag ba a))\n(# (fold (flip join) empty bag-of-bags))\n(if (and (:: Bool (.-first bag-of-bags))\n    (:: Bool (.Iterable.isIterable global.Immutable (.first bag-of-bags))))\n  (:: bba (.apply (.-concat (.first bag-of-bags)) (.first bag-of-bags) (.toArray (.rest bag-of-bags))))\n  (fold (flip join) empty bag-of-bags)))\n\nempty? (fn [collection]\n(= 0 (size collection)))\n\nnot-elem? (fn [what in]\n(not (elem? what in)))\n\nelement-array (macro [set]\n(: (Fn (Set a) (Array a)))\n(Js.call (Js.access set "toList") {}))\n\nvalue-array (macro [map]\n(: (Fn (Map k v) (Array v)))\n(Js.call (Js.access map "toList") {}))\n\nentry-array (macro [map]\n(: (Fn (Map k v) (Array [k v])))\n(Js.call (Js.access\n    (Js.call (Js.access map "entrySeq") {}) "toList") {}))\n\nconcat-map (fn [what over]\n(: (Fn (Fn a bb) (m a) bb) (Bag (m bb) bb) (Bag bb b) (Mappable m))\n(concat (map what over)))\n\nrepeat (fn [times what]\n(map (const what) (range 0 times)))\n\nconcat-repeat (fn [times what]\n(concat (repeat times what)))\n\nconcat-with (fn [with what]\n(from-? empty (fold join-with None what))\njoin-with (fn [x maybe-joined]\n  (Some (match maybe-joined\n      None x\n      (Some joined) (concat {joined with x})))))\n\nmap-into (fn [what into over]\n(fold-right append into over)\nappend (fn [x to]\n  (& (what x) to)))\n\nzip-into (fn [with into left right]\n(if (or (empty? left) (empty? right))\n  into\n  (& (with (!! (first left)) (!! (first right)))\n    (zip-into with into (rest left) (rest right)))))\n\nparse-int (fn [string]\n(: (Fn String Num))\n(.parseInt (global) string))\n\nnum-to-string (fn [n]\n(format "%n" n))\n\ncombine (fn [first second]\n(concat-map (zip tuple first) (map (repeat (size first)) second)))\n\nunique (fn [bag]\n(: (Fn ba ba) (Appendable ba a) (Bag ba a))\n(fold & empty (to-set bag)))\n\nsingleton (fn [x]\n(: (Fn a ba) (Appendable ba a) (Bag ba a))\n(& x empty))\n\nsplit (fn [bag]\n(: (Fn ba (Array ba)) (Appendable ba a) (Bag ba a))\n(fold wrap {} bag)\nwrap (fn [x all]\n  (&& (singleton x) all)))\n\nbreak-on (fn [on seq]\n(: (Fn (Fn a Bool) seq [seq seq]) (Seq seq a))\n(# Not implemented!\n  (if (empty? seq)\n    [seq seq]\n    (if (on x)\n      [empty seq]\n      [(& x fails) rest]))\n  [fails rest] (break-on on xs)\n  x (!! (first seq))\n  xs (rest seq))\n[seq seq])\n\nsplit-on (macro [separator string]\n(: (Fn String String (Array String)))\n(Js.call "Immutable.List" {(Js.method string "split" {separator})}))\n\nfold-right (fn [with initial over]\n((fold wrap id over) initial)\nwrap (fn [x r acc]\n  (r (with x acc))))\n\nreduce (fn [with over]\n(fold helper None over)\nhelper (fn [x acc]\n  (match acc\n    None (Some x)\n    (Some val) (Some (with x val)))))\n\nshow-array (instance (Show (Array a))\n{(Show a)}\nshow (fn [array]\n  (format "{%s}" (concat-with " " (map show array)))))\n\nshow-list (instance (Show (List a))\n{(Show a)}\nshow (fn [list]\n  (format "(List %s)" (concat-with " " (map show list)))))\n\nshow-set (instance (Show (Set a))\n{(Show a)}\nshow (fn [set]\n  (format "(Set %s)" (concat-with " " (map show (element-array set))))))\n\nshow-map (instance (Show (Map k v))\n{(Show k) (Show v)}\nshow (fn [mapping]\n  (format "(Map %s)" (concat-with " " (map show-entry (entry-array mapping))))\n  show-entry (fn [entry]\n    (format "%s %s" (show key) (show value))\n    [key value] entry)))\n\nsum (fold + 0)\n\nproduct (fold * 1)\n\nmaximum (reduce max)\n\nminimum (reduce min)\n\nall (fold and True)\n\nany (fold or False)\n\nall-map (fn [fun list]\n(all ((map fun) list)))\n\nany-map (fn [fun list]\n(any ((map fun) list)))\n\nchar-from-code (fn [x]\n(: (Fn Num Char))\n(.fromCharCode global.String x))\n\ncode-from-char (fn [x]\n(: (Fn Char Num))\n(.charCodeAt x 0))\n\nchar-ord (instance (Ord Char)\n<= (fn [than what]\n  (<= (code-from-char than) (code-from-char what))))\n\nin-range (fn [from exlude-to what]\n(and (<= what from) (< exlude-to what)))\n\nin-range-inclusively (fn [from to what]\n(and (<= what from) (<= to what)))\n\nscan (fn [what initial over]\n(: (Fn (Fn a b b) b (m a) (m b)) (Bag (m a) a) (Deq (m b) b))\n(snd (fold adder [initial (&& initial empty)] over))\nadder (fn [x acc]\n  [next (&& next scanned)]\n  next (what x folded)\n  [folded scanned] acc))\n\nscan-into (fn [what initial into over]\n(snd (fold adder [initial (&& initial into)] over))\nadder (fn [x acc]\n  [next (&& next scanned)]\n  next (what x folded)\n  [folded scanned] acc))\n\nreapply (fn [what initial times]\n(# Applies what times starting with initial returning the last result.)\n(match times\n  0 initial\n  else (reapply what (what initial) (- 1 times))))\n\niterate (fn [what initial times]\n(# Applies what times starting with initial returning a list of the results.)\n(take times (scan (const what) initial (range 0 (- 1 times)))))\n\nuntil (fn [what next initial]\n(# Applies next until what returns True , starting with initial .)\n(if (what initial)\n  initial\n  (until what next (next initial))))\n\nelse True\n\n?-mappable (instance (Mappable ?)\nmap (fn [what over]\n  (match over\n    (Some value) (Some (what value))\n    None None)))\n\n?-zippable (instance (Zippable ?)\nzip (fn [what x y]\n  (match [x y]\n    [(Some a) (Some b)] (Some (what a b))\n    _ None)))\n\nLiftable (class [c]\n{(Mappable c)}\nlift (fn [x] (: (Fn a (c a))))\napply (fn [what to] (: (Fn (c (Fn a b)) (c a) (c b)))))\n\nChainable (class [m]\n{(Liftable m)}\nchain (fn [wrapped through] (: (Fn (m a) (Fn a (m b)) (m b)))))\n\nfollow (fn [first-wrapped second-wrapped]\n(chain first-wrapped (fn [_]\n    second-wrapped)))\n\ndo (syntax [..actions]\n(match actions\n  {x} x\n  {x ..xs} (match x\n    (` set ,to ,what) (` chain ,what (fn [_do_pattern]\n        (match _do_pattern\n          ,to (do ,..xs))))\n    _ (` follow ,x (do ,..xs)))))\n\nVoid (data Void)\n\nIo (data [a] Io [content: (Fn a)])\n\nrun-io (fn [wrapped] ((Io-content wrapped)))\n\nexec-io (fn [wrapped]\n(const Void (run-io wrapped)))\n\nchain-io (fn [wrapped through]\n(Io (fn [] (run-io (through (run-io wrapped))))))\n\nio-mappable (instance (Mappable Io)\nmap (fn [what over]\n  (chain-io over\n    (fn [x] (Io (fn [] (what x)))))))\n\nio-liftable (instance (Liftable Io)\nlift (fn [x] (Io (fn [] x)))\napply (fn [what to]\n  (chain-io what (fn [unwrapped-what]\n      (chain-io to (fn [unwrapped-to]\n          (Io (fn [] (unwrapped-what unwrapped-to)))))))))\n\nio-chainable (instance (Chainable Io)\nchain chain-io)\n\nio (syntax [expression]\n(` Io (fn [] ,expression)))\n\nrandom (io (:: Num (.random global.Math)))\n\nrandom-int (fn [from exclude-to]\n(do\n  (set p random)\n  (lift (floor (+ from (* (- from exclude-to) p))))))\n\n-> (syntax [..args]\n(match args\n  {x} x\n  {x f ..fs} (` -> (,f ,x) ,..fs)))\n'
  }
];

});
